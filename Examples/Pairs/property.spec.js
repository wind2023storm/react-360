/**
 * The examples provided by Oculus are for non-commercial testing and
 * evaluation purposes only.
 *
 * Oculus reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL
 * OCULUS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Model integration test: actions, validators, reducers and middleware.

jest.dontMock('redux');
jest.dontMock('./replicate');
jest.dontMock('./reducers');
jest.dontMock('./reducers/board');
jest.dontMock('./reducers/scores');
jest.dontMock('./reducers/validate');
jest.dontMock('./actions');
jest.dontMock('./middleware');

require('jasmine-check').install();
const createStore = require('redux').createStore;
const applyMiddleware = require('redux').applyMiddleware;
const clientPredictionConsistency = require('./replicate').clientPredictionConsistency;
const app = require('./reducers').default;
const isValid = require('./reducers/validate').isValid;
const countEquals = require('./reducers/validate').countEquals;
const syncState = require('./actions').syncState;
const showSquare = require('./actions').showSquare;
const hideSquare = require('./actions').hideSquare;
const scoreSquare = require('./actions').scoreSquare;
const filterUnknownSenderActions = require('./middleware').filterUnknownSenderActions;
const replicateNonHandshakeActions = require('./middleware').replicateNonHandshakeActions;
//const logActions = require('./middleware').logActions;
//const logState = require('./middleware').logState;
const width = require('./reducers/board').width;
const height = require('./reducers/board').height;
const initialBoard = require('./reducers/board').initialState();
const copyBoard = require('./reducers/board').copyState;

const fakeIsMaster = () => true;

const masterId = '0000-UUID';
const aClientId = 'AAAA-UUID';
const bClientId = 'BBBB-UUID';
const clients = [masterId, aClientId, bClientId];
const zeroScores = () => {
  return Object.assign({}, ...clients.map(n => ({[n]: []})));
};

let fakeSend;
let replicateActions;
let store;

beforeEach(() => {
  fakeSend = jest.fn();
  replicateActions = clientPredictionConsistency(syncState, fakeIsMaster, isValid, fakeSend);
  store = createStore(
    app,
    {board: copyBoard(initialBoard), scores: zeroScores()},
    applyMiddleware(
      filterUnknownSenderActions,
      replicateNonHandshakeActions(fakeSend, replicateActions)
      //logActions(masterId),
      //logState
    )
  );
});

const genShow = gen.posInt.then(n => {
  const row = n % height;
  const column = Math.floor(n / height) % width;
  return gen.oneOf(clients).then(client => {
    return showSquare(row, column, client);
  });
});
const genHide = genShow.then(showAction => {
  return hideSquare(showAction);
});
const genScore = gen.posInt.then(n => {
  const value = n % (width * height / 2) + 1;
  return gen.oneOf(clients).then(client => {
    return scoreSquare(client, value);
  });
});
const genAction = gen.oneOf([genShow, genHide, genScore]);

describe('optimistic consistency', () => {
  // check that for any sequence of actions, all of the pairs that have been
  // scored are visible.
  check.it('all scored pairs are shown', {times: 1000}, gen.array(genAction), actions => {
    store.dispatch(syncState({board: copyBoard(initialBoard), scores: zeroScores()}));
    actions.forEach(action => {
      store.dispatch(action);
    });
    const state = store.getState();
    Object.keys(state.scores).forEach(client => {
      state.scores[client].forEach(value => {
        expect(countEquals(state.board, value)).toEqual(2);
      });
    });
  });

  const sendCount = (send, type) => {
    return send.mock.calls.filter(call => {
      return call[0].type === type;
    }).length;
  };

  // clientPredictionConsistency is only eventually consistent if for any sequence
  // of actions that causes a conflict, then every ordering of that sequence causes
  // a conflict. test that property holds by counting the sync actions generated
  // by a sequence of actions matches the number of send calls generated by
  // dispatching that sequence of actions in reverse.
  check.it('sync action is order independent', {times: 1000}, gen.array(genAction), actions => {
    store.dispatch(syncState({board: copyBoard(initialBoard), scores: zeroScores()}));
    const reverse = Array.from(actions).reverse();
    fakeSend.mockClear();
    actions.forEach(action => {
      store.dispatch(action);
    });
    const sync = sendCount(fakeSend, 'SYNC_STATE') > 0;
    store.dispatch(syncState({board: copyBoard(initialBoard), scores: zeroScores()}));
    fakeSend.mockClear();
    reverse.forEach(action => {
      store.dispatch(action);
    });
    expect(sendCount(fakeSend, 'SYNC_STATE') > 0).toEqual(sync);
  });
});
