/**
 * The examples provided by Oculus are for non-commercial testing and
 * evaluation purposes only.
 *
 * Oculus reserves all rights not expressly granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL
 * OCULUS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Model integration test: actions, validators, reducers and middleware.

jest.dontMock('redux');
jest.dontMock('./replicate');
jest.dontMock('./reducers');
jest.dontMock('./reducers/board');
jest.dontMock('./reducers/scores');
jest.dontMock('./reducers/validate');
jest.dontMock('./actions');
jest.dontMock('./middleware');

require('jasmine-check').install();
const createStore = require('redux').createStore;
const applyMiddleware = require('redux').applyMiddleware;
const resyncConsistency = require('./replicate').resyncConsistency;
const replayConsistency = require('./replicate').replayConsistency;
const app = require('./reducers').default;
const isValid = require('./reducers/validate').isValid;
const countEquals = require('./reducers/validate').countEquals;
const syncState = require('./actions').syncState;
const showSquare = require('./actions').showSquare;
const hideSquare = require('./actions').hideSquare;
const scoreSquare = require('./actions').scoreSquare;
const filterUnknownSenderActions = require('./middleware').filterUnknownSenderActions;
const replicateNonHandshakeActions = require('./middleware').replicateNonHandshakeActions;
const timestampActions = require('./middleware').timestampActions;
//const logActions = require('./middleware').logActions;
//const logState = require('./middleware').logState;
const width = require('./reducers/board').width;
const height = require('./reducers/board').height;
const initialBoard = require('./reducers/board').initialState();
const copyBoard = require('./reducers/board').copyState;

let fakeIsMaster = () => true;

const masterId = '0000-UUID';
const aClientId = 'AAAA-UUID';
const bClientId = 'BBBB-UUID';
const clients = [masterId, aClientId, bClientId];
const zeroScores = () => {
  return Object.assign({}, ...clients.map(n => ({[n]: []})));
};

const fakeSend = jest.fn();
let store = null;

const createReplicatedStore = (replicationMiddleware, localClient) => {
  return createStore(
    app,
    {board: copyBoard(initialBoard), scores: zeroScores()},
    applyMiddleware(
      filterUnknownSenderActions,
      timestampActions(localClient),
      replicateNonHandshakeActions(fakeSend, replicationMiddleware)
      //logActions(masterId),
      //logState
    )
  );
};

const sendCount = (send, type) => {
  return send.mock.calls.filter(call => {
    return call[0].type === type;
  }).length;
};

const sentActions = (send, client) => {
  return send.mock.calls.map(call => ({...call[0], sender: client}));
};

const allScoredPairsShown = state => {
  return Object.keys(state.scores).every(client => {
    state.scores[client].forEach(value => {
      expect(countEquals(state.board, value)).toEqual(2);
    });
  });
};

const genShow = gen.posInt.then(n => {
  const row = n % height;
  const column = Math.floor(n / height) % width;
  return gen.oneOf(clients).then(client => {
    return showSquare(row, column, client);
  });
});

const genHide = genShow.then(showAction => {
  return hideSquare(showAction);
});

const genScore = gen.posInt.then(n => {
  const value = n % (width * height / 2) + 1;
  return gen.oneOf(clients).then(client => {
    return scoreSquare(client, value);
  });
});

const genAction = gen.oneOf([genShow, genHide, genScore]);

describe('resyncConsistency', () => {
  // check that for any sequence of actions, all of the pairs that have been
  // scored are visible.
  check.it('all scored pairs are shown', {times: 1000}, gen.array(genAction), actions => {
    store = createReplicatedStore(resyncConsistency(syncState, fakeIsMaster, isValid, fakeSend));
    actions.forEach(action => {
      store.dispatch(action);
    });
    expect(allScoredPairsShown(store.getState()));
  });

  // resyncConsistency is only eventually consistent if for any sequence
  // of actions that causes a conflict, then every ordering of that sequence causes
  // a conflict. test that property holds by counting the sync actions generated
  // by a sequence of actions matches the number of send calls generated by
  // dispatching that sequence of actions in reverse.
  check.it('sync action is order independent', {times: 1000}, gen.array(genAction), actions => {
    store = createReplicatedStore(resyncConsistency(syncState, fakeIsMaster, isValid, fakeSend));
    const reverse = Array.from(actions).reverse();
    fakeSend.mockClear();
    actions.forEach(action => {
      store.dispatch(action);
    });
    const sync = sendCount(fakeSend, 'SYNC_STATE') > 0;
    store = createReplicatedStore(resyncConsistency(syncState, fakeIsMaster, isValid, fakeSend));
    fakeSend.mockClear();
    reverse.forEach(action => {
      store.dispatch(action);
    });
    expect(sendCount(fakeSend, 'SYNC_STATE') > 0).toEqual(sync);
  });
});

describe('replayConsistency', () => {
  // check that for any sequence of actions, all of the pairs that have been
  // scored are visible.
  check.it('all scored pairs are shown', {times: 1000}, gen.array(genAction), actions => {
    store = createReplicatedStore(replayConsistency(syncState, fakeIsMaster, isValid, fakeSend));
    actions.forEach(action => {
      store.dispatch(action);
    });
    expect(allScoredPairsShown(store.getState()));
  });

  // check that clients are eventually consistent in the pathological case when each
  // client reduces all of its actions before receiving any actions from any other client
  check.it('clients are eventually consistent', {times: 1000}, gen.array(genAction), actions => {
    // generate actions sent by client a if it predicted all of its actions
    fakeIsMaster = sender => false;
    fakeSend.mockClear();
    store = createReplicatedStore(
      replayConsistency(syncState, fakeIsMaster, isValid, fakeSend),
      aClientId
    );
    const aClientActions = [...actions.filter(action => action.client === aClientId)];
    aClientActions.forEach(store.dispatch);
    const aClientSentActions = sentActions(fakeSend, aClientId);

    // generate actions sent by client b if it predicted all of its actions
    fakeIsMaster = sender => false;
    fakeSend.mockClear();
    store = createReplicatedStore(
      replayConsistency(syncState, fakeIsMaster, isValid, fakeSend),
      bClientId
    );
    const bClientActions = [...actions.filter(action => action.client === bClientId)];
    bClientActions.forEach(store.dispatch);
    const bClientSentActions = sentActions(fakeSend, bClientId);

    // generate actions sent by master after receiving actions from a then b
    fakeIsMaster = sender => true; // master client, actions from non-masters
    fakeSend.mockClear();
    store = createReplicatedStore(
      replayConsistency(syncState, fakeIsMaster, isValid, fakeSend),
      masterId
    );
    aClientSentActions.forEach(store.dispatch);
    bClientSentActions.forEach(store.dispatch);
    const masterSentActions = [...sentActions(fakeSend, masterId)];
    const masterState = {...store.getState()}; // save master end state

    // reduce client a predictions then master sent actions as a
    fakeIsMaster = sender => (sender ? sender === masterId : false);
    fakeSend.mockClear();
    store = createReplicatedStore(
      replayConsistency(syncState, fakeIsMaster, isValid, fakeSend),
      aClientId
    );
    aClientActions.forEach(store.dispatch);
    masterSentActions.forEach(store.dispatch);
    expect(store.getState()).toEqual(masterState); // expect that client a is eventually consistent

    // reduce client b predictions then master sent actions as b
    fakeIsMaster = sender => (sender ? sender === masterId : false);
    fakeSend.mockClear();
    store = createReplicatedStore(
      replayConsistency(syncState, fakeIsMaster, isValid, fakeSend),
      bClientId
    );
    bClientActions.forEach(store.dispatch);
    masterSentActions.forEach(store.dispatch);
    expect(store.getState()).toEqual(masterState); // expect that client b is eventually consistent
  });
});
